/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "DSM.h"

#include <stdio.h>
#include <stdlib.h>

#include <string.h>

#include <sys/ipc.h>
#include <sys/types.h>
#include <sys/shm.h>
#include <signal.h>
#include<sys/mman.h>

#include <pthread.h>

#define SHMSIZE 100

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
// channelCount is count of other channels
#define channelCount 2
#define MAXREQUESTS 10
#define MAXRES 5



typedef enum { false,true } bool;

char nullStr[1] = "\0";
struct Resource
{
	char fileName[20];
	char state;
	char data[1000];
	char upcomingID[20];			  // upcoming id means somebody already has requested M from this node
	int replyDeferred[channelCount]; // replyDeferred[i] contains val for node i+1
};

struct Node
{
	char IP[20];
	int nodeNum;
	struct Resource res[100];
};

struct srchIndex
{
	int nodeId;
	int resId;
	char op;
};

struct localNode local[MAXREQUESTS];
// nodes[channelCount] i.e. last index  will store current node data
struct Node nodes[channelCount + 1];
struct ReqNode imrequesting[MAXREQUESTS];

int ifImRequesting(char fname[])
{
    int i = 0;
    int flag = -1;
    for (i = 0; i < MAXREQUESTS; i++)
    {
        flag = (strcmp(fname, imrequesting[i].fileName) == 0 && imrequesting[i].bRequestingCS == true) ? true : false;
        flag = i;
    }
    return flag;
}


void SendMUpdates(char fname[], char state)
{
	printf("*******Enter SendMUpdates*******\n");
	int i = 0;
	for (i = 0; i < channelCount; i++)
	{
		CLIENT *clnt;
		ReqNode *result_1;
		ReqNode req;
		setReqNodeInitials(&req);
		strcpy(req.fileName, fname);
		req.state = state;

		clnt = clnt_create(nodes[i].IP, GetUpdates_PROG, GetUpdates_VERS, "tcp");
		if (clnt == NULL)
		{
			clnt_pcreateerror(nodes[i].IP);
			exit(1);
		}
		
		result_1 = getupdates_1(&req, clnt);
		if (result_1 == (ReqNode *)NULL)
		{
			clnt_perror(clnt, "call failed");
		}
		clnt_destroy(clnt);
	}
	printf("*******Exit SendMUpdates*******\n");
}



void setReqNodeInitials(ReqNode *n)
{
	n->bRequestingCS = 0;
	strcpy(n->data, nullStr);
	strcpy(n->fileName, nullStr);
	n->nodeNum = nodes[channelCount].nodeNum;
	strcpy(n->IP, nodes[channelCount].IP);
}

struct srchIndex SearchRes(char name[], char op)
{
	printf("*******Enter SearchRes*******\n");

	struct srchIndex s;
	s.nodeId = -1;
	s.resId = -1;
	s.op = 'A';
	int i = 0, j = 0;
	bool flag = false;
	for (i = 0; i <= channelCount; i++)
	{
		j = 0;
		while (strlen(nodes[i].res[j].fileName) > 0)
		{
			if (
				(strcmp(nodes[i].res[j].fileName, name) == 0 && nodes[i].res[j].state == op) ||
				(i == channelCount && strcmp(nodes[i].res[j].fileName, name) == 0 && nodes[i].res[j].state != 'I')        												)
			{
				s.nodeId = i;
				s.resId = j;
				s.op = op;
				flag = true;
				break;
			}
			j++;
		}
		if (flag)
			break;
	}
	printf("*******Exit SearchRes*******\n");

	return s;
}

struct srchIndex fileExists(char name[])
{
	printf("*******Enter fileExists*******\n");

	struct srchIndex s;
	s.nodeId = -1;
	s.resId = -1;
	s.op = 'A';
	int i = 0, j = 0;
	bool flag = false;

	j = 0;
	while (strlen(nodes[channelCount].res[j].fileName) > 0)
	{
		if (strcmp(nodes[channelCount].res[j].fileName, name) == 0)
		{
			s.nodeId = channelCount;
			s.resId = j;
			s.op = nodes[i].res[j].state;
			flag = true;
			break;
		}
		j++;
	}

	printf("*******Exit fileExists*******\n");
	return s;
}

void sendAdd(char fname[], char state)
{
	printf("*******Enter sendAdd*******\n");
	int i = 0;
	for (i = 0; i < channelCount; i++)
	{	
		printf("Entered loop\n");
		CLIENT *clnt;
		ReqNode *result_1;
		ReqNode req;
		setReqNodeInitials(&req);
		strcpy(req.fileName, fname);
		req.state = state;
		
		clnt = clnt_create(nodes[i].IP, GetAdd_PROG, GetAdd_VERS, "tcp");
		if (clnt == NULL)
		{	
			
			clnt_pcreateerror(nodes[i].IP);
			exit(1);
		}
		
		result_1 = getadd_1(&req, clnt);
		
		if (result_1 == (ReqNode *)NULL)
		{
			clnt_perror(clnt, "call failed");
		}
		else 
		{
			
		}
		clnt_destroy(clnt);
	}
	printf("*******Exit sendAdd*******\n");
}

int *initializeserver_1_svc(initializationNode *argp, struct svc_req *rqstp)
{
	static int result;
	printf("*******Enter initializeserver_1_svc*******\n");
	printf("%s\nIPS.........................", argp->ips);

	char ips[500];
	strcpy(ips, argp->ips);


	int count = 0, j = 0, i = 0, k = 0;

	while (j < strlen(ips))
	{
		if (ips[j] == ',')
		{
			nodes[count].IP[i] = '\0';
			i = 0;
			j++;
			count++;
		}
		else
		{
			nodes[count].IP[i] = ips[j];
			j++;
			i++;
		}
	}

	for (i = 0; i < channelCount; i++)
	{
		for (j = 0; j < MAXRES; j++)
		{
			nodes[i].res[j].state = 'I';
			for (k = 0; k < channelCount; k++)
			{
				nodes[i].res[j].replyDeferred[k] = -1;
			}
		}
	 }

	// initialize my requesting node
	for (i = 0; i < MAXREQUESTS; i++)
	{
		setReqNodeInitials(&imrequesting[i]);
		imrequesting[i].state = 'I';
		imrequesting[i].seqNum = 0;
		imrequesting[i].bRequestingCS = 0;

		// initialize local node
		strcpy(local[i].IP, nodes[channelCount].IP);
		local[i].highestSeqNum = 1;
		local[i].outstandingReplies = channelCount;
		local[i].state = 'I';
		strcpy(local[i].fileName, nullStr);
		local[i].offset = 0;
		local[i].requestStatus = 0; // 0 means wait for others , -1 means abort Tx
	}
	printf("*******Exit initializeserver_1_svc*******\n");

	return &result;
}

char *
getmemptr_1_svc(localNode *argp, struct svc_req *rqstp)
{
	static char result;

	/*
	 * insert server code here
	 */

	return &result;
}

localNode *
getlocaldata_1_svc(localNode *argp, struct svc_req *rqstp)
{
	static localNode result;
	
	

	return &result;
}

ReqNode *
recrep_1_svc(ReqNode *argp, struct svc_req *rqstp)
{
	int i=0,j=0;
	static ReqNode result;
	if(argp->lockId > -1)
	{
		// actually it should always be true
		// find local node at this position and verify OSR etc.

		local[argp->lockId].outstandingReplies--;
		if(strlen(argp->data) > 0)
		{
			j = 0;
			while (strcmp(nodes[channelCount].res[j].fileName, argp->fileName) != 0)
			{
				j++;
			} 
			strcpy(nodes[channelCount].res[j].data,argp->data);	
		}
		if(local[argp->lockId].outstandingReplies == 0 && argp->state == 'M')
		{
			SendMUpdates(argp->fileName, argp->state);
		}
		printf("decreased OSR:, as reply was not deferred%d\n", local[argp->lockId].outstandingReplies);
	}
 	if(local[argp->lockId].outstandingReplies == 0){
	printf("################Lock is with : %d OSR: %d highest seq number %d lockID : %d \n",imrequesting[argp->lockId].nodeNum,local[argp->lockId].outstandingReplies,local[argp->lockId].highestSeqNum,argp->lockId);
	}
	return &result;
}

void GetAddT(void *arg)
{
	struct ReqNode *argp = (ReqNode *)arg;

	// while adding we need to make sure that res is added into my local node too but without data and shall be in I state
	pthread_mutex_lock(&mutex);
	int i = 0;
	int j = 0;
	int k=0;
	while (strcmp(nodes[i].IP, argp->IP) != 0)
	{
		i++;
	}
	while (strlen(nodes[i].res[j].fileName) > 0)
	{
		j++;
	}

	strcpy(nodes[i].res[j].fileName, argp->fileName);
	nodes[i].res[j].state = argp->state;

	j=0;
	while (strlen(nodes[channelCount].res[j].fileName) > 0)
	{
		j++;
	}
	nodes[channelCount].res[j].state = 'I';
	strcpy(nodes[channelCount].res[j].fileName,argp->fileName);
	strcpy(nodes[channelCount].res[j].data, nullStr);
	for(k=0;k<channelCount;k++)
	{
		nodes[channelCount].res[j].replyDeferred[k] = -1;
	}

	pthread_mutex_unlock(&mutex);
	 
}

ReqNode *
getadd_1_svc(ReqNode *argp, struct svc_req *rqstp)
{
	ReqNode result;
	
	// while adding we need to make sure that res is added into my local node too but without data and shall be in I state
	pthread_mutex_lock(&mutex);
	int i = 0;
	int j = 0;
	int k=0;
	while (strcmp(nodes[i].IP, argp->IP) != 0)
	{
		i++;
	}
	while (strlen(nodes[i].res[j].fileName) > 0)
	{
		j++;
	}

	strcpy(nodes[i].res[j].fileName, argp->fileName);
	nodes[i].res[j].state = argp->state;

	j=0;
	while (strlen(nodes[channelCount].res[j].fileName) > 0)
	{
		j++;
	}
	nodes[channelCount].res[j].state = 'I';
	strcpy(nodes[channelCount].res[j].fileName,argp->fileName);
	strcpy(nodes[channelCount].res[j].data, nullStr);
	for(k=0;k<channelCount;k++)
	{
		nodes[channelCount].res[j].replyDeferred[k] = -1;
	}

	pthread_mutex_unlock(&mutex);
	j=0;
	while(strlen(nodes[channelCount].res[j].fileName) > 0)	
	{printf("file name is %s at location %d\n",nodes[channelCount].res[j].fileName,j); j++;}

	//pthread_t t1;
	//pthread_create(&t1, NULL, GetAddT, argp);
	//pthread_join(t1, NULL);

	return &result;
}

 

ReqNode *
getupdates_1_svc(ReqNode *argp, struct svc_req *rqstp)
{
	ReqNode result;
	int i=0,j=0;
	bool flag = false;
	if(argp->state == 'M')
	{
		pthread_mutex_lock(&mutex);
		for (i = 0; i < channelCount; i++)
		{	
			j = 0;
			while (strlen(nodes[i].res[j].fileName) > 0)
			{
				if (strcmp(nodes[i].res[j].fileName, argp->fileName) == 0)
				{
					if(nodes[i].res[j].state == 'M')
					{
						nodes[i].res[j].state = 'I';
						flag = true;
						break;
					}
				}
				j++;
			}
			if(flag)break; 
		}
		flag = false;
		for (i = 0; i < channelCount; i++)
		{
			if (strcmp(nodes[i].IP, argp->IP) == 0)
			{
				break;
			}
		}
			
		j = 0;
		while (strlen(nodes[i].res[j].fileName) > 0)
		{
			if (strcmp(nodes[i].res[j].fileName, argp->fileName) == 0)
			{
				nodes[i].res[j].state = 'M';
			}
			j++;
		}
		pthread_mutex_unlock(&mutex);
	}
	else{
		printf("_______________________________Error with LOGIC_________________________________\n");
	}


	return &result;
}
 

void CreateRes(void *arg)
{
	int i = 0, j = 0;
	printf("*******Enter CreateRes*******\n");

	struct localNode *argp = (localNode *)arg;

	char fname[20];
	char state;
	int index;
	strcpy(fname, argp->fileName);
	
	state = argp->operation;
	index = argp->lockId;

	pthread_mutex_lock(&mutex);
	i = 0;
	while (strlen(nodes[channelCount].res[i].fileName) > 0)
	{
		i++;
	}

	strcpy(nodes[channelCount].res[i].fileName, fname);
	nodes[channelCount].res[i].state = state;
	// reinitialize typical res data
	for (j = 0; j < channelCount; j++)
	{
		nodes[channelCount].res[i].replyDeferred[j] = -1; // res[i] have not deferred anybody requesting this res
	}
	strcpy(nodes[channelCount].res[i].data, nullStr);
	strcpy(nodes[channelCount].res[i].upcomingID, nullStr);

	// seeing these 2, local client can happily take control of this
	local[index].outstandingReplies = 0;
	local[index].requestStatus = 1;

	pthread_mutex_unlock(&mutex);
	pthread_exit(NULL);
	printf("*******Exit CreateRes*******\n");
}

ReqNode *
sendadd_1_svc(ReqNode *argp, struct svc_req *rqstp)
{
	static ReqNode  result;

	/*
	 * insert server code here
	 */

	return &result;
}
ReqNode *
sendupdates_1_svc(ReqNode *argp, struct svc_req *rqstp)
{
	static ReqNode  result;

	/*
	 * insert server code here
	 */

	return &result;
}
localNode *
reqcs1_1_svc(localNode *argp, struct svc_req *rqstp)
{
	static localNode  result;

	/*
	 * insert server code here
	 */

	return &result;
}




localNode *
reqcs_1_svc(localNode *argp, struct svc_req *rqstp)
{
	static localNode result;
	printf("*******Enter reqcs_1_svc*******\n");

	int i = 0;
	int runTimes = 0;

	struct srchIndex sindex;
	sindex = fileExists(argp->fileName);

	if (sindex.nodeId == -1)
	{
		//item does not exist anywhere hence new item is required to be created
		pthread_t t1;
		pthread_create(&t1, NULL, CreateRes, argp);
		pthread_join(t1, NULL);

		//CreateRes(argp);
		char state = 'S'; 
		state = argp->operation;
		sendAdd(argp->fileName, state);
	}
	else
	{
		int j=0;
		// item exists
		sindex = SearchRes(argp->fileName, 'M');
		if (sindex.nodeId == -1)
		{
			//  nobody is holding exclusive lock
			for (i = 0; i < channelCount; i++)
			{
				CLIENT *clnt;
				ReqNode *result_1;

				imrequesting[argp->lockId].bRequestingCS = 1;
				imrequesting[argp->lockId].seqNum = local[argp->lockId].highestSeqNum + 1;
				imrequesting[argp->lockId].lockId = argp->lockId;
				strcpy(imrequesting[argp->lockId].data, nullStr);
				strcpy(imrequesting[argp->lockId].fileName, argp->fileName);
				imrequesting[argp->lockId].state = argp->state;

				printf("sending request to %s for my lock number  %d\n",nodes[i].IP,argp->lockId);


				clnt = clnt_create(nodes[i].IP, RecReq_PROG, RecReq_VERS, "tcp");
				if (clnt == NULL)
				{
					clnt_pcreateerror(nodes[i].IP);
					exit(1);
				}
			
				result_1 = recreq_1(&imrequesting[argp->lockId], clnt);
				if (result_1 == (ReqNode *)NULL)
				{
					clnt_perror(clnt, "call failed");
				}
				else
				{
					printf("received reply from %s for request with my lockid %d\n",nodes[i].IP,argp->lockId);
					if(result_1->resultCode == 0)
					{
						// deferred me so i set my req status to deferred
						local[argp->lockId].requestStatus = 0;

					}
					else if(result_1->resultCode == 1)
					{
						local[argp->lockId].outstandingReplies--;
						if(strlen(result_1->data) > 0)
						{
							j = 0;
							while (strcmp(nodes[channelCount].res[j].fileName, argp->fileName) != 0)
							{
								j++;
							} 
							strcpy(nodes[channelCount].res[j].data,result_1->data);	 
							
						}
						if(local[argp->lockId].outstandingReplies == 0 && argp->state == 'M')
						{
							SendMUpdates(argp->fileName, argp->state);
						}
	printf("decreased OSR:, as reply was not deferred%d\n", local[argp->lockId].outstandingReplies);

if(local[argp->lockId].outstandingReplies == 0){
	printf("################Lock is with : %d OSR: %d highest seq number %d lockID : %d \n",imrequesting[argp->lockId].nodeNum,local[argp->lockId].outstandingReplies,local[argp->lockId].highestSeqNum,argp->lockId);
	}

						
					}
				}
				clnt_destroy(clnt);
			}
			//******** later when i get my OSR to 0, i will broad-cast and go to CS *********
		}
		else
		{
			if (sindex.nodeId == channelCount)
			{
				// i am holding but i don't know if S or M (and this is intentional to showcase signal handling with mprotect)
				local[argp->lockId].outstandingReplies  = 0;

			}
			else
			{
				local[argp->lockId].outstandingReplies = channelCount - 1;
				// somebody (only one is holding)
				CLIENT *clnt;
				ReqNode *result_1;

				imrequesting[argp->lockId].bRequestingCS = 1;
				imrequesting[argp->lockId].seqNum = local[argp->lockId].highestSeqNum + 1;
				imrequesting[argp->lockId].lockId = argp->lockId;
				strcpy(imrequesting[argp->lockId].data, nullStr);
				strcpy(imrequesting[argp->lockId].fileName, argp->fileName);
				imrequesting[argp->lockId].state = argp->state;

				clnt = clnt_create(nodes[sindex.nodeId].IP, RecReq_PROG, RecReq_VERS, "tcp");
				if (clnt == NULL)
				{
					clnt_pcreateerror(nodes[sindex.nodeId].IP);
					exit(1);
				}

				result_1 = recreq_1(&imrequesting[argp->lockId], clnt);
				if (result_1 == (ReqNode *)NULL)
				{
					clnt_perror(clnt, "call failed");
				}
				else
				{
					if(result_1->resultCode == 0)
					{
						// deferred me 
						
					}
					else if(result_1->resultCode == 1)
					{
						local[argp->lockId].outstandingReplies--;
						if(strlen(result_1->data) > 0)
						{
							j = 0;
							while (strcmp(nodes[channelCount].res[j].fileName, argp->fileName) != 0)
							{
								j++;
							} 
							strcpy(nodes[channelCount].res[j].data,result_1->data);	 
						}
						if(local[argp->lockId].outstandingReplies == 0 && result_1->state == 'M')
						{
							SendMUpdates(argp->fileName, argp->state);
						}


						printf("decreased OSR:, as reply was not deferred%d\n", local[argp->lockId].outstandingReplies);						
					}
				}
				clnt_destroy(clnt);
			}
		}
	}

	printf("*******Exit reqcs_1_svc*******\n");
	return &result;
}



ReqNode *
recreq_1_svc(ReqNode *argp, struct svc_req *rqstp)
{
	int i = 0, j = 0;
	static ReqNode result;
	 
	 
	printf("***********recieved req from : %s  for file : %s for his lock : %d\n",argp->IP,argp->fileName,argp->lockId);
	

	printf("*******Enter recreq_1_svc*******\n");
	int myCorrespondingNodeId = -1;
	ReqNode resultNode;
	setReqNodeInitials(&resultNode); 

	myCorrespondingNodeId = ifImRequesting(argp->fileName);

	bool bDefer = false;

	local[myCorrespondingNodeId].highestSeqNum = MAX(local[myCorrespondingNodeId].highestSeqNum, argp->seqNum);

	bDefer = (myCorrespondingNodeId >=0 && ((argp->seqNum > imrequesting[myCorrespondingNodeId].seqNum) && (imrequesting[myCorrespondingNodeId].seqNum > 0) ||
			(argp->seqNum == imrequesting[myCorrespondingNodeId].seqNum && argp->nodeNum > imrequesting[myCorrespondingNodeId].nodeNum)));
	
	if (bDefer && (argp->state == 'M' || imrequesting[myCorrespondingNodeId].state == 'M' )) 
	{
		printf("Deferred sending message to %d\n", argp->nodeNum);

		//set reply deferred true
		j = 0;
		while (strcmp(nodes[channelCount].res[j].fileName, argp->fileName) != 0 && strlen(nodes[channelCount].res[j].fileName) >0 )
		{
			j++;
		}
		nodes[channelCount].res[j].replyDeferred[argp->nodeNum - 1] = argp->lockId;
		resultNode.resultCode = 0;
	}
	else
	{
		//set resultNode data part and return
		j = 0;
		while (strcmp(nodes[channelCount].res[j].fileName, argp->fileName) != 0  && strlen(nodes[channelCount].res[j].fileName) >0)
		{
			j++;
		}
		strcpy(resultNode.data, nodes[channelCount].res[j].data);
		resultNode.resultCode = 1;
	}	
	resultNode.lockId = argp->lockId;
	strcpy(resultNode.fileName, argp->fileName);
	resultNode.state  = argp->state; // save state requested 

	printf("*******Exit recreq_1_svc*******\n");

	return &resultNode;
}


// change this to informrelease lock
localNode *
dummy1_1_svc(localNode *argp, struct svc_req *rqstp)
{
	static localNode result;
	
	local[argp->lockId].highestSeqNum = MAX ( local[argp->lockId].highestSeqNum, imrequesting[argp->lockId].seqNum);
	
	imrequesting[argp->lockId].bRequestingCS = false;

	int i=0,j=0;
	while(strcmp(nodes[channelCount].res[i].fileName,argp->fileName) != 0)
	{
		i++;
	}
	for(j =0;j<channelCount;j++)
	{
		if(nodes[channelCount].res[i].replyDeferred[j] > -1)
		{
			ReqNode req;
			ReqNode *result_1;
			setReqNodeInitials(&req);
			strcpy(req.fileName, argp->fileName);
			req.lockId = nodes[channelCount].res[i].replyDeferred[j];
			CLIENT *clnt; 
			clnt = clnt_create (nodes[i].IP, RecRep_PROG, RecRep_VERS, "tcp");
			if (clnt == NULL) {
				clnt_pcreateerror (nodes[i].IP);
				exit (1);
			}
			result_1 = recrep_1(&req, clnt);
			if (result_1 == (int *) NULL) {
				clnt_perror (clnt, "call failed");
			}
			else{
				printf("Now successfully sent the deferred reply to: %s\n",nodes[i].IP);
			}
			clnt_destroy (clnt); 

		}
	}
	return &result;
}

char *
dummy2_1_svc(ReqNode *argp, struct svc_req *rqstp)
{
	static char result;

	/*
	 * insert server code here
	 */

	return &result;
}

ReqNode *
dummy3_1_svc(ReqNode *argp, struct svc_req *rqstp)
{
	static ReqNode result;

	/*
	 * insert server code here
	 */

	return &result;
}
 
